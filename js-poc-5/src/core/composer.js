import { LLMClient } from "./llmClient.js";
import { GitHubClient } from "./githubClient.js";

export class Composer {
  constructor(options = {}) {
    this.llmClient = options.llmClient || new LLMClient();
    this.githubClient = options.githubClient || new GitHubClient();
    this.enableComposition = options.enableComposition || process.env.UA_ENABLE_COMPOSITION === "true";
  }

  async composeSolutions(mainTaskDescription, solutionResults) {
    console.log(`🔧 Composing solutions for main task: ${mainTaskDescription}`);
    
    if (!this.enableComposition) {
      console.log("🚫 Composition is disabled");
      return {
        status: "disabled",
        message: "Composition is disabled in configuration"
      };
    }

    try {
      // Step 1: Prepare solution data
      const subtaskSolutions = await this.prepareSolutionData(solutionResults);
      
      if (subtaskSolutions.length === 0) {
        throw new Error("No valid solutions available for composition");
      }

      console.log(`📋 Composing ${subtaskSolutions.length} solutions`);
      
      // Step 2: Generate composed solution using LLM
      const composedSolution = await this.llmClient.composeSolutions(
        mainTaskDescription,
        subtaskSolutions
      );
      
      // Step 3: Create branch for the composed solution
      const branchName = this.githubClient.generateBranchName("composition", mainTaskDescription);
      await this.githubClient.createBranch(branchName);
      
      // Step 4: Create composed solution file
      const composedFileName = this.generateComposedFileName(mainTaskDescription);
      const composedFilePath = `src/${composedFileName}`;
      
      await this.githubClient.createOrUpdateFile(
        composedFilePath,
        composedSolution,
        `Add composed solution for: ${mainTaskDescription}`,
        branchName
      );
      
      // Step 5: Create documentation
      const documentation = await this.generateDocumentation(
        mainTaskDescription,
        subtaskSolutions,
        composedSolution
      );
      
      const docFilePath = `docs/${this.generateDocFileName(mainTaskDescription)}`;
      await this.githubClient.createOrUpdateFile(
        docFilePath,
        documentation,
        `Add documentation for: ${mainTaskDescription}`,
        branchName
      );
      
      // Step 6: Create pull request for the composed solution
      const pullRequest = await this.createCompositionPullRequest(
        mainTaskDescription,
        branchName,
        composedFilePath,
        docFilePath,
        subtaskSolutions
      );
      
      return {
        composedSolution,
        composedFilePath,
        documentation,
        docFilePath,
        branchName,
        pullRequest,
        status: "success"
      };
    } catch (error) {
      console.error("Composition failed:", error);
      throw error;
    }
  }

  async prepareSolutionData(solutionResults) {
    const subtaskSolutions = [];
    
    for (const result of solutionResults) {
      if (result.status === "success" && result.solutionCode) {
        subtaskSolutions.push({
          title: result.subtaskIssue.title,
          description: result.subtaskIssue.subtaskData?.description || "",
          code: result.solutionCode,
          filePath: result.solutionFilePath
        });
      }
    }
    
    return subtaskSolutions;
  }

  generateComposedFileName(mainTaskDescription) {
    return mainTaskDescription
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, "")
      .replace(/\s+/g, "-")
      .substring(0, 40) + ".js";
  }

  generateDocFileName(mainTaskDescription) {
    return mainTaskDescription
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, "")
      .replace(/\s+/g, "-")
      .substring(0, 40) + ".md";
  }

  async generateDocumentation(mainTaskDescription, subtaskSolutions, composedSolution) {
    const timestamp = new Date().toISOString();
    const solutionsList = subtaskSolutions.map((sol, index) => 
      `${index + 1}. **${sol.title}**\n   - File: \`${sol.filePath}\`\n   - Description: ${sol.description}`
    ).join("\n\n");

    return `# ${mainTaskDescription}

## Overview
This document describes the composed solution for the main task "${mainTaskDescription}".

*Generated by Universal Algorithm on ${timestamp}*

## Task Decomposition
The main task was decomposed into ${subtaskSolutions.length} subtasks:

${solutionsList}

## Composed Solution
The individual solutions have been integrated into a single, cohesive solution that addresses all requirements.

### Implementation Details
- **Main File**: \`${this.generateComposedFileName(mainTaskDescription)}\`
- **Architecture**: Modular design combining all subtask solutions
- **Testing**: Comprehensive test coverage for all functionality

### Key Features
${subtaskSolutions.map(sol => `- ${sol.title}`).join("\n")}

## Usage
\`\`\`javascript
import { /* main exports */ } from './${this.generateComposedFileName(mainTaskDescription)}';

// Example usage will be documented here
\`\`\`

## Testing
Run the test suite to verify all functionality:
\`\`\`bash
npm test
\`\`\`

## Maintenance
This solution was generated using the Universal Algorithm. Each component corresponds to a specific subtask and can be maintained independently while preserving the overall integration.

---
*Documentation generated by Universal Algorithm*`;
  }

  async createCompositionPullRequest(mainTaskDescription, branchName, composedFilePath, docFilePath, subtaskSolutions) {
    const title = `[COMPOSITION] ${mainTaskDescription}`;
    
    const solutionsList = subtaskSolutions.map((sol, index) => 
      `${index + 1}. ${sol.title}`
    ).join("\n");

    const description = `## Composed Solution for Main Task

This pull request provides the final composed solution that integrates all subtask solutions into a complete implementation.

### Solution Details
- **Main File**: \`${composedFilePath}\`
- **Documentation**: \`${docFilePath}\`
- **Subtasks Integrated**: ${subtaskSolutions.length}

### Integrated Components
${solutionsList}

### Testing
- [ ] All individual subtask tests pass
- [ ] Integration tests pass
- [ ] Code follows best practices
- [ ] Solution is complete and production-ready

### Definition of Done
- [x] All subtasks have been solved
- [x] Solutions have been composed into a cohesive implementation
- [x] Documentation is complete
- [ ] Final testing and review completed

### Next Steps
1. Review the composed solution
2. Run comprehensive tests
3. Approve and merge if successful
4. Deploy to production

---
*This composed solution was generated by the Universal Algorithm*`;
    
    return await this.githubClient.createPullRequest(
      title,
      description,
      branchName,
      "main"
    );
  }

  async updateMainIssueWithComposition(mainIssueNumber, compositionResult) {
    const comment = `## Composition Complete ✅

The final composed solution has been generated:
- **Composition PR**: #${compositionResult.pullRequest.number}
- **Main File**: \`${compositionResult.composedFilePath}\`
- **Documentation**: \`${compositionResult.docFilePath}\`

### Next Steps
1. Review the composition PR
2. Run comprehensive tests
3. Approve and merge if successful
4. Close this issue as complete

---
*Updated by the Universal Algorithm*`;
    
    await this.githubClient.addIssueComment(mainIssueNumber, comment);
    console.log(`📝 Updated main issue #${mainIssueNumber} with composition PR #${compositionResult.pullRequest.number}`);
  }

  async validateComposition(composedSolution, subtaskSolutions) {
    // Basic validation of the composed solution
    const validations = [
      {
        check: composedSolution.trim().length > 0,
        message: "Composed solution should not be empty"
      },
      {
        check: composedSolution.includes("export") || composedSolution.includes("module.exports"),
        message: "Composed solution should export functionality"
      },
      {
        check: subtaskSolutions.every(sol => 
          composedSolution.includes(sol.title.toLowerCase().replace(/\s+/g, "")) ||
          composedSolution.includes(sol.title.replace(/\s+/g, ""))
        ),
        message: "Composed solution should reference all subtask components"
      },
      {
        check: !composedSolution.includes("TODO") && !composedSolution.includes("FIXME"),
        message: "Composed solution should not contain TODO or FIXME comments"
      }
    ];

    const failedValidations = validations.filter(v => !v.check);
    
    if (failedValidations.length > 0) {
      const errors = failedValidations.map(v => v.message).join(", ");
      console.warn(`Composition validation warnings: ${errors}`);
    }
    
    return {
      isValid: failedValidations.length === 0,
      warnings: failedValidations.map(v => v.message)
    };
  }

  async getCompositionStatus(compositionPRNumber) {
    try {
      // In a real implementation, you'd check the PR status and test results
      return {
        prNumber: compositionPRNumber,
        status: "pending_review",
        testsPass: null // Would be determined by CI/CD
      };
    } catch (error) {
      console.error("Failed to get composition status:", error);
      throw error;
    }
  }
} 