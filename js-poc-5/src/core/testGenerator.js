import { LLMClient } from "./llmClient.js";
import { GitHubClient } from "./githubClient.js";

export class TestGenerator {
  constructor(options = {}) {
    this.llmClient = options.llmClient || new LLMClient();
    this.githubClient = options.githubClient || new GitHubClient();
  }

  async generateTestForSubtask(subtaskIssue) {
    console.log(`🧪 Generating test for subtask #${subtaskIssue.number}: ${subtaskIssue.title}`);
    
    try {
      const subtaskData = subtaskIssue.subtaskData;
      
      // Step 1: Generate test using LLM
      const testCode = await this.llmClient.generateTest(
        subtaskData.title,
        subtaskData.description,
        subtaskData.acceptanceCriteria
      );
      
      // Step 2: Create branch for the test
      const branchName = this.githubClient.generateBranchName("test", subtaskData.title);
      await this.githubClient.createBranch(branchName);
      
      // Step 3: Create test file
      const testFileName = this.generateTestFileName(subtaskData.title);
      const testFilePath = `__tests__/${testFileName}`;
      
      await this.githubClient.createOrUpdateFile(
        testFilePath,
        testCode,
        `Add failing test for: ${subtaskData.title}`,
        branchName
      );
      
      // Step 4: Create pull request for the test
      const pullRequest = await this.createTestPullRequest(
        subtaskData.title,
        subtaskIssue.number,
        branchName,
        testFilePath
      );
      
      // Step 5: Update subtask issue with test PR link
      await this.updateSubtaskWithTestPR(subtaskIssue.number, pullRequest.number);
      
      return {
        testCode,
        testFilePath,
        branchName,
        pullRequest
      };
    } catch (error) {
      console.error("Test generation failed:", error);
      throw error;
    }
  }

  async generateTestsForAllSubtasks(subtaskIssues) {
    console.log(`🧪 Generating tests for ${subtaskIssues.length} subtasks`);
    
    const results = [];
    
    for (const subtaskIssue of subtaskIssues) {
      try {
        const result = await this.generateTestForSubtask(subtaskIssue);
        results.push({
          subtaskIssue,
          ...result,
          status: "success"
        });
      } catch (error) {
        console.error(`Failed to generate test for subtask #${subtaskIssue.number}:`, error);
        results.push({
          subtaskIssue,
          status: "failed",
          error: error.message
        });
      }
    }
    
    return results;
  }

  generateTestFileName(subtaskTitle) {
    return subtaskTitle
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, "")
      .replace(/\s+/g, "-")
      .substring(0, 40) + ".test.js";
  }

  async createTestPullRequest(subtaskTitle, subtaskIssueNumber, branchName, testFilePath) {
    const title = `[TEST] ${subtaskTitle}`;
    const description = `## Test for Subtask #${subtaskIssueNumber}

This pull request adds a failing test that defines the "definition of done" for the subtask.

### Test Details
- **File**: \`${testFilePath}\`
- **Purpose**: Define acceptance criteria as executable tests
- **Status**: ❌ Currently failing (as expected)

### Next Steps
1. Review and approve this test PR
2. Merge the failing test
3. Create solution PR to make tests pass

### Related
- Subtask Issue: #${subtaskIssueNumber}

---
*This test was generated by the Universal Algorithm*`;
    
    return await this.githubClient.createPullRequest(
      title,
      description,
      branchName,
      "main"
    );
  }

  async updateSubtaskWithTestPR(subtaskIssueNumber, testPRNumber) {
    const comment = `## Test Generated ✅

A failing test has been generated for this subtask:
- **Test PR**: #${testPRNumber}

### Next Steps
1. Review and approve the test PR
2. Merge the failing test
3. Generate solution to make tests pass

---
*Updated by the Universal Algorithm*`;
    
    await this.githubClient.addIssueComment(subtaskIssueNumber, comment);
    console.log(`📝 Updated subtask #${subtaskIssueNumber} with test PR #${testPRNumber}`);
  }

  async validateTest(testCode, subtaskData) {
    // Basic validation of the generated test
    const validations = [
      {
        check: testCode.includes("describe("),
        message: "Test should include describe block"
      },
      {
        check: testCode.includes("it(") || testCode.includes("test("),
        message: "Test should include test cases"
      },
      {
        check: testCode.includes("expect("),
        message: "Test should include expectations"
      },
      {
        check: subtaskData.acceptanceCriteria.some(criteria => 
          testCode.toLowerCase().includes(criteria.toLowerCase().substring(0, 10))
        ),
        message: "Test should relate to acceptance criteria"
      }
    ];

    const failedValidations = validations.filter(v => !v.check);
    
    if (failedValidations.length > 0) {
      const errors = failedValidations.map(v => v.message).join(", ");
      console.warn(`Test validation warnings: ${errors}`);
    }
    
    return {
      isValid: failedValidations.length === 0,
      warnings: failedValidations.map(v => v.message)
    };
  }

  async getTestStatus(testPRNumber) {
    try {
      // In a real implementation, you'd check the PR status and test results
      // For now, return basic status
      return {
        prNumber: testPRNumber,
        status: "pending_review",
        testsPass: false // Should be false for newly generated tests
      };
    } catch (error) {
      console.error("Failed to get test status:", error);
      throw error;
    }
  }
} 