import { decomposeTask } from "./decomposer.js";
import { generateTest } from "./testGenerator.js";
import { createIssue, createSubIssue, createPullRequest } from "./githubClient.js";

/**
 * End-to-end orchestration of the universal algorithm:
 * 1. Create main GitHub issue for the task.
 * 2. Decompose into subtasks and create sub-issues.
 * 3. For each subtask, generate failing test and open pull request containing the test.
 *
 * Designed for CLI usage: `bun src/orchestrator.js "Your task"`
 */
export async function run(taskDescription) {
  // Step 1: Create main issue
  const mainIssue = await createIssue(taskDescription, "Generated by the universal algorithm orchestrator");
  console.log(`Created main issue #${mainIssue.number}`);

  // Step 2: Decompose
  const subtasks = await decomposeTask(taskDescription);
  console.log("Subtasks:", subtasks);

  // Step 3: Sub-issues and PRs
  for (const subtask of subtasks) {
    const subIssue = await createSubIssue(mainIssue.number, subtask, "Auto-generated sub-issue");
    console.log(`Created sub-issue #${subIssue.number}`);

    const testContent = await generateTest(subtask);

    // TODO: In real scenario we would create a branch, commit test file, push and open PR.
    // For prototype we just create a PR stub referencing the sub-issue.
    await createPullRequest(
      `feat/${subIssue.number}-test`,
      `Add failing test for ${subtask}`,
      `This PR introduces a failing test for #${subIssue.number}.\n\n\`\`\`js\n${testContent}\n\`\`\``
    );
  }
}

// CLI execution
if (import.meta.main) {
  const task = Bun.argv.slice(2).join(" ");
  if (!task) {
    console.error("Usage: bun src/orchestrator.js \"Your task description\"");
    process.exit(1);
  }
  await run(task);
} 