import { Octokit } from '@octokit/rest';
import chalk from 'chalk';
import { RepositoryManager } from './repositoryManager.js';

export class GitHubClient {
  constructor() {
    this.octokit = new Octokit({ 
      auth: process.env.GITHUB_TOKEN,
      baseUrl: process.env.GITHUB_API_BASE_URL || 'https://api.github.com'
    });
    this.repo = {
      owner: process.env.GITHUB_OWNER,
      repo: process.env.GITHUB_REPO
    };
    this.dryRun = process.env.UNIVERSAL_ALGORITHM_DRY_RUN === 'true';
    this.repositoryManager = new RepositoryManager();
    this.testRepository = null;
  }

  /**
   * Handle rate limiting by waiting for the reset time
   */
  async handleRateLimit(error) {
    if (error.status === 429 && error.message.includes('rate limit')) {
      const resetTime = error.response?.headers?.['x-ratelimit-reset'];
      if (resetTime) {
        const waitTime = Math.max(0, (parseInt(resetTime) * 1000) - Date.now()) + 1000; // Add 1 second buffer
        console.log(chalk.yellow(`  ‚è≥ Rate limit hit, waiting ${Math.ceil(waitTime / 1000)} seconds until reset...`));
        await new Promise(resolve => setTimeout(resolve, waitTime));
        return true; // Indicates we handled the rate limit
      }
    }
    return false; // Indicates we didn't handle the rate limit
  }

  /**
   * Execute a GitHub API call with rate limit handling
   */
  async executeWithRateLimit(apiCall) {
    const maxRetries = 3;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await apiCall();
      } catch (error) {
        if (error.status === 403 && error.message.includes('rate limit')) {
          const handled = await this.handleRateLimit(error);
          if (handled && attempt < maxRetries) {
            console.log(chalk.blue(`  üîÑ Retrying API call (attempt ${attempt + 1}/${maxRetries})...`));
            continue;
          }
        }
        throw error;
      }
    }
  }

  async createIssue(title, body, parentIssue = null) {
    try {
      if (this.dryRun) {
        console.log(chalk.gray(`  üìù [DRY-RUN] Would create issue: "${title}"`));
        return Math.floor(Math.random() * 1000) + 1; // Mock issue number
      }

      const issue = await this.executeWithRateLimit(async () => {
        return await this.octokit.issues.create({
          ...this.repo,
          title,
          body: `${body}\n\n---\n*Created by Problem Solving Automation*`
        });
      });
      
      if (parentIssue) {
        await this.executeWithRateLimit(async () => {
          return await this.octokit.issues.createComment({
            ...this.repo,
            issue_number: parentIssue,
            body: `Subtask created: #${issue.data.number}`
          });
        });
      }
      
      return issue.data.number;
    } catch (error) {
      console.error(chalk.red('  ‚ùå Error creating issue:'), error.message);
      throw error;
    }
  }

  async createPullRequest(title, branch, content, issueNumber) {
    try {
      if (this.dryRun) {
        console.log(chalk.gray(`  üìù [DRY-RUN] Would create PR: "${title}"`));
        return { 
          prNumber: Math.floor(Math.random() * 1000) + 1,
          url: `https://github.com/${this.repo.owner}/${this.repo.repo}/pull/123`
        };
      }

      // Get the default branch first
      const { data: repoInfo } = await this.executeWithRateLimit(async () => {
        return await this.octokit.repos.get({
          ...this.repo
        });
      });
      const baseBranch = repoInfo.default_branch || 'main';

      // Create branch
      const baseBranchData = await this.executeWithRateLimit(async () => {
        return await this.octokit.repos.getBranch({
          ...this.repo,
          branch: baseBranch
        });
      });

      await this.executeWithRateLimit(async () => {
        return await this.octokit.git.createRef({
          ...this.repo,
          ref: `refs/heads/${branch}`,
          sha: baseBranchData.data.commit.sha
        });
      });

      // Create file
      const fileName = this.getFileNameFromTitle(title);
      await this.executeWithRateLimit(async () => {
        return await this.octokit.repos.createOrUpdateFileContents({
          ...this.repo,
          path: fileName,
          message: title,
          content: Buffer.from(content).toString('base64'),
          branch: branch
        });
      });

      // Create PR with timeout
      const prPromise = this.executeWithRateLimit(async () => {
        return await this.octokit.pulls.create({
          ...this.repo,
          title: title,
          head: branch,
          base: baseBranch,
          body: `Closes #${issueNumber}\n\n---\n*Generated by Problem Solving Automation*`
        });
      });

      // Add timeout to PR creation (30 seconds)
      const pr = await Promise.race([
        prPromise,
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('PR creation timed out after 30 seconds')), 30000)
        )
      ]);

      return {
        prNumber: pr.data.number,
        url: pr.data.html_url
      };
    } catch (error) {
      console.error(chalk.red('  ‚ùå Error creating PR:'), error.message);
      throw error;
    }
  }

  async getApprovalStatus(prNumber) {
    try {
      if (this.dryRun) {
        console.log(chalk.gray(`  üìù [DRY-RUN] Would check approval status for PR #${prNumber}`));
        return true; // Mock approval
      }

      // For testing purposes, simulate a quick approval check
      // In production, this would check for actual approvals
      await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay
      
      // For now, always approve in test mode
      if (process.env.NODE_ENV === 'test' || process.env.UNIVERSAL_ALGORITHM_TEST_MODE === 'true') {
        return true;
      }
      
      // In production, check for actual approvals
      const { data: reviews } = await this.executeWithRateLimit(async () => {
        return await this.octokit.pulls.listReviews({
          ...this.repo,
          pull_number: prNumber
        });
      });
      
      // Check if there are any approving reviews
      const hasApproval = reviews.some(review => review.state === 'APPROVED');
      return hasApproval;
    } catch (error) {
      console.error(chalk.red('  ‚ùå Error checking approval status:'), error.message);
      // In test mode, default to approved
      if (process.env.NODE_ENV === 'test' || process.env.UNIVERSAL_ALGORITHM_TEST_MODE === 'true') {
        return true;
      }
      return false;
    }
  }

  getFileNameFromTitle(title) {
    // Convert title to filename
    const sanitized = title
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    
    return `src/${sanitized}.js`;
  }

  /**
   * Create a test repository for this session
   */
  async createTestRepository(description) {
    try {
      this.testRepository = await this.repositoryManager.createTestRepository(description);
      
      // Update the repo configuration to use the test repository
      this.repo = {
        owner: this.testRepository.fullName.split('/')[0],
        repo: this.testRepository.fullName.split('/')[1]
      };
      
      console.log(chalk.blue(`  üéØ Using test repository: ${this.testRepository.fullName}`));
      return this.testRepository;
    } catch (error) {
      // Handle rate limiting specifically for repository creation
      if (error.status === 403 && error.message.includes('rate limit')) {
        console.log(chalk.yellow('  ‚è≥ Rate limit hit during repository creation, waiting...'));
        const handled = await this.handleRateLimit(error);
        if (handled) {
          // Retry repository creation after waiting
          return await this.createTestRepository(description);
        }
      }
      console.error(chalk.red('  ‚ùå Error creating test repository:'), error.message);
      throw error;
    }
  }

  /**
   * Delete the test repository if tests were successful
   */
  async cleanupTestRepository(success = false) {
    if (!this.testRepository) {
      console.log(chalk.gray('  ‚ÑπÔ∏è  No test repository to clean up'));
      return;
    }

    if (this.dryRun) {
      console.log(chalk.gray(`  üìù [DRY-RUN] Would ${success ? 'delete' : 'keep'} test repository: ${this.testRepository.name}`));
      return;
    }

    // When deleteOnSuccess is false, we just log and return - no operations that could fail
    if (!this.repositoryManager.deleteOnSuccess) {
      if (success) {
        console.log(chalk.green(`  ‚úÖ Keeping test repository (deleteOnSuccess=false): ${this.testRepository.url}`));
      } else {
        console.log(chalk.yellow(`  üíæ Keeping test repository for investigation: ${this.testRepository.url}`));
        console.log(chalk.gray(`  üìù Repository will need manual cleanup when investigation is complete`));
      }
      return;
    }

    // Only attempt deletion when deleteOnSuccess is true
    if (success) {
      try {
        await this.repositoryManager.deleteTestRepository(this.testRepository.name);
      } catch (error) {
        console.error(chalk.red(`  ‚ùå Failed to delete test repository ${this.testRepository.name}:`), error.message);
        console.log(chalk.yellow(`  üí° Repository ${this.testRepository.url} will need manual cleanup`));
      }
    } else {
      console.log(chalk.yellow(`  üíæ Keeping test repository for investigation: ${this.testRepository.url}`));
      console.log(chalk.gray(`  üìù Repository will need manual cleanup when investigation is complete`));
    }
  }

  /**
   * Get the current test repository info
   */
  getTestRepositoryInfo() {
    return this.testRepository;
  }
} 